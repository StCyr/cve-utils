#!/usr/bin/perl

# TODO
# REACHED ophcrack (just before igor_pavlov)
# 1 - implement version match
# 3 - Find solution for ati:ccc-utility (should be control_center-utility...)
# 4 - Find a solution for adobe_flash_player_18_npapi & co.
# 5 - Find a solution for microsoft_office_publisher_mui_(english)_2010 & co.
# 6 - Find a solution for adobe_reader_x_(10.1.2)
# 7 - Fix problem of "google earth" (why no underscore?)
# 8 - notepad++
# 9 - Fix problem of "skype™_7.0" (why no product version match?)
# 10 - Fix problem of "irfanview_(remove_only)" => need to remove "(remove_only)"
# 11 - Fix problem of "gcc-4.8" (not identified as a gnu product)
# 12 - Fix problem of "linux-image-3.13.0-44-generic" (should be identified)
# 13 - Fix problem of "lvm2" (readhat or heinz...?)
# 15 - Fix problem of debian products
# 16 - Fix problem of gnome products
# 16 - Fix problem of realvnc
# 17 - Fix problem of "spybot_-_search_&_destroy" (& should become and)
# 18 - java is a ibm product in CPE dictionary

use Getopt::Long;
use Log::Message::Simple;
use Pod::Usage;
use XML::LibXML;
use DBI;

no warnings 'experimental::smartmatch';

binmode STDOUT, ":encoding(UTF-8)";

local $Log::Message::Simple::MSG_FH     = \*STDERR;
local $Log::Message::Simple::DEBUG_FH   = \*STDERR;

# Read config file
require './soft2cpe.conf';

# Get options
my ($debug,$help,$init,$verbose) = 0;
my ($vendor,$version);

GetOptions( 'debug' => \$debug,
  'help' => \$help,
  'init' => \$init,
  'vendor=s'  => \$vendor,
  'verbose'   => \$verbose,
  'version=s' => \$version,
);

pod2usage(3) if $help;

$verbose=1 if $debug;

# Open the CPE dictionary SQLite database.
my $dsn = "DBI:SQLite:dbname=$cpe_dictionary";
my $dbh = DBI->connect( $dsn,'','', {RaiseError => 1} ) or die $DBI::errstr;

# Initialise a new CPE dictionary if requested
init_cpe_dict() if ($init);

# At least a soft name must be given
my $soft = @ARGV[0];
if ( !defined $soft and !defined $init) {
  pod2usage(3);
  exit 1;
}

# Skip MS updates
if ($soft =~ /update_for_microsoft/ || $soft =~ /update_kb/ || $soft =~ /hotfix_kb/ || $soft =~ /update_for_windows/) {
  die "Software appears to be a Microsoft update, which I don't handle yet, sorry.\n";
} 

# Do some basic CPE formating on vendor and product
$vendor =~ tr/ A-Z/_a-z/ ; 
$vendor =~ s/\+/\\\+/g; 
$soft =~ tr/\t A-Z/__a-z/ ; 
$soft =~ s/\+/\\\+/g; 

# Identify possible vendors and products
my %possible_vendors = identify_possible_vendors();
my %possible_products = identify_possible_products();

# Identify possible CPE entries
my %possible_cpe_entries = identify_possible_cpe_entries();
my $match = keys %possible_cpe_entries;
if ($match) {
  
  # Order list by increasing order of confidence
  foreach my $cpe (sort { $possible_cpe_entries{$a} <=> $possible_cpe_entries{$b} } keys %possible_cpe_entries) {
      $best_cpe = $cpe; 
      my $string = sprintf( "Found CPE entry $cpe with a confidence of %.2f" , $possible_cpe_entries{$cpe} );
      msg($string,$verbose);
  }

  print "$best_cpe\n";
  exit 0;

} else {
  msg("No match found.",$verbose);
  exit -1;
}


###############################
#
# Sub routines start here
#


# Identify all possible vendors based on the given vendor name, and return an hash array 
# containing all possible vendors with a confidence rating.
sub identify_possible_vendors {
  my %possible_vendors;

  # If vendor not provided or 'unknown', assign it the product's name
  if ( $vendor eq "" || $vendor =~ /unknown/i ) { 
    debug("Vendor not provided, setting it to \"$soft\"",$debug);
    $vendor = $soft;
    $possible_vendors{$vendor} = 0.5;
  } else {
    $possible_vendors{$vendor} = 0.8; 
  }

  # Try to match vendor against a known pattern
  debug("Trying to match \"$vendor\" against a known pattern",$debug);
  while ( my ($key, $value) = each (%vendor_match) ) {
    debug("Trying to match \"$vendor\" against \"$key\"",$debug);
    if ( $vendor =~ /$key/ or $vendor =~ /\Q$key\E/ ) {
      debug("Matched \"$vendor\" against \"$key\"",$debug);
      $possible_vendors{$value} = 0.9;
    }
  }

  # Try to detect GNU product
  debug("Trying to detect a GNU product",$debug);
  if ( "$soft" ~~ @gnu_products ) {
    debug("\"$soft\" is a GNU product.",$debug);
    $possible_vendors{'gnu'} = 0.9;
  }
  
  if ($verbose) {
    msg("Following possible vendors were found:",$verbose);
    msg("$_ $h{$possible_vendors}",$verbose) for (keys %possible_vendors);
  }

  return %possible_vendors;
} 



# Identify all possible products based on the given product name, and return an hash array 
# containing all possible products with a confidence rating.
sub identify_possible_products {
  my %added_softs;
  my %possible_products;

  $possible_products{$soft} = 0.8;

  # Try to remove some unnecessary header from product name
  debug("Trying to remove some unnecessary header from product name",$debug);
  foreach my $to_trim ( @product_leading_trim ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      debug("Trying to remove leading \"$to_trim\" from \"$soft\"",$debug);
      my ($trimmed) = $product =~ /^$to_trim(.*)/;
      if ( $trimmed ) {
        debug("Removed leading \"$to_trim\" from \"$soft\"",$debug);
        $added_softs{$trimmed} = $confidence / 0.9;
      }
    }
  }

  # Add trimmed soft to possible_products
  @possible_products{ keys %added_softs } = values %added_softs;

  # Reset hashes and iterators
  keys %possible_products;
  %{$added_softs}=();

  # Try to remove unnecessary trailing version number from product name
  foreach my $regex ( @version_regex ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      if ( $product =~ /$regex/ ) {
        my $trimmed = $1;
        my $version = $2;
        $added_softs{$trimmed} = $confidence / 0.9;
      }
    }
  }

  # Add trimmed soft to possible_products
  @possible_products{ keys %added_softs } = values %added_softs;
  
  # Reset hashes and iterators
  keys %possible_products;
  %{$added_softs}=();

  # Try to match product against a known pattern
  while ( my ($product, $confidence) = each (%possible_products) ) {
    while ( my ($key, $value) = each (%product_match) ) {
      if ( $product =~ /$key/ ) {
        $added_softs{$value} = $confidence / 0.8;
      }
    }
  }

  # Add modified soft to possible_products
  @possible_products{ keys %added_softs } = values %added_softs;

  if ($verbose) {
    msg("Following possible products were found:",$verbose);
    msg("$_ $h{$possible_products}",$verbose) for (keys %possible_products);
  }

  return %possible_products;
}


#
# Identify possible CPE entries for each possible (vendor,product) found
#
sub identify_possible_cpe_entries {
  my %possible_cpe_entries;
 
  my $sth = $dbh->prepare("SELECT rowid FROM SOFTS WHERE VENDOR=? AND SOFT=? LIMIT 1");

  while ( my ($vendor, $vendor_confidence) = each (%possible_vendors) ) {

    while ( my ($soft, $product_confidence) = each (%possible_products) ) {

      # Lookup (vendor,product) tuple in CPE dictionary
      my $ret =  $sth->execute($vendor,$soft);
      my ($rowid) = $sth->fetchrow_array; 

      # Add to list of possibly matching CPE entries
      if ( $rowid ) {
        $possible_cpe_entries{"$vendor:$soft"} = $vendor_confidence * $product_confidence;
      }

    }

  }

  return %possible_cpe_entries;

}

#
# Initialize CPE dictionary database
#
sub init_cpe_dict {

  print "Initialising CPE dictionary database, please wait...\n",

  # Initialise SQLite database
  my $stmt = qq(PRAGMA journal_mode=WAL;);
  my $ret = $dbh->do($stmt); 
  $stmt = qq(PRAGMA synchronous=NORMAL;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(PRAGMA locking_mode=EXCLUSIVE;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(DROP TABLE IF EXISTS SOFTS;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(DROP TABLE IF EXISTS VERSIONS;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(CREATE TABLE SOFTS (
      VENDOR  TEXT NOT NULL,
      SOFT    TEXT NOT NULL);
  );
  $ret = $dbh->do($stmt); 
  $stmt = qq(CREATE TABLE VERSIONS (
      SOFT     INTEGER PRIMARY KEY ASC,
      VERSION  TEXT NOT NULL,
      FOREIGN KEY(SOFT) REFERENCES SOFTS(rowid)
    ) WITHOUT ROWID;
  );
  $ret = $dbh->do($stmt); 

  # Read the official CPE dictionary
  my $parser = XML::LibXML->new();
  my $tree = $parser->parse_file($official_cpe_dictionary);
  my $cpe_dict = $tree->getDocumentElement;
  my @cpe_list = $cpe_dict->getElementsByTagName('cpe-23:cpe23-item');

  # Populates the SQLite database from the official CPE dictionary
  my $rowid = 1;
  my $sth1 = $dbh->prepare("INSERT INTO SOFTS (rowid,VENDOR,SOFT) VALUES (?,?,?)");
  my $sth2 = $dbh->prepare("INSERT INTO VERSIONS (SOFT,VERSION) VALUES (?,?)");
  foreach my $cpe (@cpe_list) {

    # skip deprecated entries
    my @deprecations = $cpe->getElementsByTagName('cpe-23:deprecation');
    if (@deprecations) { next }

    # get CPE entry's data and add it to SQLite database
    my ($dummy1, $dummy2, $platform, $vendor, $soft, $version, $update, $edition, $lang) = split /(?<!\\)\Q:\E/, $cpe->getAttribute('name');
    $ret = $sth1->execute($rowid,$vendor,$soft); 
    $ret = $sth2->execute($rowid,$version); 
    print "$rowid records processed\r";
    $rowid++;
    
  }
  
  print "\ndone\n";

  exit;

}

__END__

=head1 soft2cpe.pl

soft2cpe.pl - Program to translate a software name into a corresponding CPE entry

=head1 SYNOPSIS

soft2cpe.pl [options] "software name"

  Options:
    --debug   print debugging information (implies "--verbose")
    --help    print this text
    --init    initialise the CPE SQLite database file.
    --vendor  provide the name of the software's vendor
    --verbose output verbose processing information 
    --version provide the software's version

=head1 OPTIONS

=over 4

=item B<--debug>

  Output debugging information about what soft2cpl.pl is doing. Implies "--debug".

=item B<--help>
   
  Print help

=item B<--init>

  soft2cpe.pl uses a SQLite database for its operation. This option tells soft2cpe.pl to create this database.

=item B<--vendor> 

  Specify the name of the software vendor.

=item B<--verbose>

  Output verbose information about what soft2cpl.pl is doing. Use "--debug" for even more details.
  
=item B<--version> 

  Specify the version of the software. This option as no effect for the moment.

=back 

=head1 DESCRIPTION

=cut
