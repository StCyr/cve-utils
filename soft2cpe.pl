#!/usr/bin/perl

use Getopt::Long;
use Log::Message::Simple;
use Pod::Usage;
use XML::LibXML;
use DBI;

no warnings 'experimental::smartmatch';

binmode STDOUT, ":encoding(UTF-8)";

local $Log::Message::Simple::MSG_FH     = \*STDERR;
local $Log::Message::Simple::DEBUG_FH   = \*STDERR;

# Read config file
require './soft2cpe.conf';

# Get options
my ($debug,$help,$init,$verbose) = 0;
my ($vendor,$version);

GetOptions( 'debug' => \$debug,
  'help' => \$help,
  'init' => \$init,
  'vendor=s'  => \$vendor,
  'verbose'   => \$verbose,
  'version=s' => \$version,
);

pod2usage(3) if $help;

$verbose=1 if $debug;

# Open the CPE dictionary SQLite database.
my $dsn,$dbh;
if ( -f $cpe_dictionary or $init) {
  $dsn = "DBI:SQLite:dbname=$cpe_dictionary";
  $dbh = DBI->connect( $dsn,'','', {RaiseError => 1} ) or die $DBI::errstr;
} else {
  die "No CPE dictionary found, aborting. Please use \"--init\" to create one (See \"--help\" for more info).";
}

# Initialise a new CPE dictionary if requested
init_cpe_dict() if ($init);

# At least a soft name must be given
my $soft = @ARGV[0];
if ( !defined $soft and !defined $init) {
  pod2usage(3);
  exit 1;
}

# Do some basic CPE formating on vendor and product
$vendor =~ tr/ A-Z/_a-z/ ; 
$vendor =~ s/\+/\\\+/g; 
$vendor =~ s/[^\x20-\x7e]/_/g;
$soft =~ tr/\t A-Z/__a-z/ ; 
$soft =~ s/\+/\\\+/g; 
$soft =~ s/[^\x20-\x7e]/_/g;

# Some products need to be skipped (eg: MS updates,...)
foreach my $skip ( @products2skip ) {
  if ( $soft =~ /$skip/ ) {
    die "Product appears in the list of products to skip, sorry.\n";
  }
} 

# Identify possible vendors and products
my %possible_vendors;
identify_possible_vendors();
my %possible_products;
identify_possible_products();

# Verbose output
if ($verbose) {
  msg("Following possible vendors were found:",$verbose);
  msg("$_ $h{$possible_vendors}",$verbose) for (keys %possible_vendors);
  msg("Following possible products were found:",$verbose);
  msg("$_ $h{$possible_products}",$verbose) for (keys %possible_products);
}

# Identify possible CPE entries
my %possible_cpe_entries;
identify_possible_cpe_entries();
my $match = keys %possible_cpe_entries;
if ($match) {
  
  # Order list by increasing order of confidence
  foreach my $cpe (sort { $possible_cpe_entries{$a} <=> $possible_cpe_entries{$b} } keys %possible_cpe_entries) {
      $best_cpe = $cpe; 
      my $string = sprintf( "Found CPE entry $cpe with a confidence of %.2f" , $possible_cpe_entries{$cpe} );
      msg($string,$verbose);
  }

  print "$best_cpe\n";
  exit 0;

} else {
  msg("No match found.",$verbose);
  exit -1;
}


###############################
#
# Sub routines start here
#


# Identify all possible vendors based on the given vendor name
sub identify_possible_vendors {

  $possible_vendors{$soft}   = 0.5;
  if ( $vendor ne "" and !($vendor =~ /unknown/) ) {
    $possible_vendors{$vendor} = 0.8; 
  }

  # Try to match vendor against a known pattern
  debug("** Trying to match \"$vendor\" against a known pattern",$debug);
  while ( my ($key, $value) = each (%vendor_match) ) {
    debug("Trying to match \"$vendor\" against \"$key\"",$debug);
    if ( $vendor =~ /$key/ or $vendor =~ /\Q$key\E/ ) {
      debug("Matched \"$vendor\" against \"$key\"",$debug);
      $possible_vendors{$value} = 0.9;
    }
  }

  # Try to match vendor based on product
  debug("** Trying to match vendor based on product name",$debug);
  while ( my ($key, $value) = each (%product2vendor) ) {
    debug("Trying to match \"$soft\" against \"$key\"",$debug);
    if ( $soft =~ /$key/ ) {
      debug("Matched \"$soft\" against \"$key\"",$debug);
      $possible_vendors{$value} = 0.9;
    }
  }

  return;
} 



# Identify all possible products based on the given product name, and return an hash array 
# containing all possible products with a confidence rating.
sub identify_possible_products {
  my %added_softs;

  $possible_products{$soft} = 0.8;

  # Try to remove leading vendor name from product name
  debug("** Trying to remove leading vendor name from product name",$debug);
  foreach my $to_trim ( @product_leading_vendor ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      debug("Trying to remove leading \"$to_trim\" from \"$soft\"",$debug);
      my ($trimmed) = $product =~ /^$to_trim(.*)/;
      if ( $trimmed ) {
        debug("Removed leading \"$to_trim\" from \"$soft\"",$debug);
        $added_softs{$trimmed} = $confidence / 0.9;
        # Add found vendor name to the list of possible vendor if not yet done
        chop $to_trim;
        if ( !exists $possible_vendors{$to_trim} ) {
          $possible_vendors{$to_trim} = 0.9;
          debug("Added \"$to_trim\" to the list of possible vendors",$debug);
        }
      }
    }
  }

  # Add trimmed soft to possible_products
  @possible_products{ keys %added_softs } = values %added_softs;

  # Reset hashes and iterators
  keys %possible_products;
  %{$added_softs}=();

  # Try to remove some trailing crap from product name
  debug("** Trying to remove trailing crap from product name",$debug);
  foreach my $regex ( @product_trailing_crap ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      debug("Trying to remove trailing \"$regex\" in \"$soft\"",$debug);
      if ( $product =~ /$regex/ ) {
        debug("Removed trailing \"$2\" in \"$soft\"",$debug);
        my $trimmed = $1;
        $added_softs{$trimmed} = $confidence / 0.9;
      }
    }
  }

  # Add trimmed soft to possible_products
  @possible_products{ keys %added_softs } = values %added_softs;

  # Reset hashes and iterators
  keys %possible_products;
  %{$added_softs}=();

  # Try to remove unnecessary trailing version number from product name
  debug("** Trying to remove trailing version number from product name",$debug);
  foreach my $regex ( @version_regex ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      debug("Trying to identify version with \"$regex\" in \"$soft\"",$debug);
      if ( $product =~ /$regex/ ) {
        my $trimmed = $1;
        my $version = $2;
        $added_softs{$trimmed} = $confidence / 0.9;
        debug("Identified version \"$version\" with \"$regex\" in \"$soft\"",$debug);
      }
    }
  }

  # Add trimmed soft to possible_products
  @possible_products{ keys %added_softs } = values %added_softs;
  
  # Reset hashes and iterators
  keys %possible_products;
  %{$added_softs}=();

  # Try to match product against a known pattern
  debug("** Trying to match product against a known pattern",$debug);
  while ( my ($product, $confidence) = each (%possible_products) ) {
    while ( my ($key, $value) = each (%product_match) ) {
      debug("Trying to match \"$product\" against \"$key\"",$debug);
      if ( $product =~ /$key/ ) {
        debug("Matched \"$product\" against \"$key\"",$debug);
        $added_softs{$value} = $confidence / 0.8;
      }
    }
  }

  # Add modified soft to possible_products
  @possible_products{ keys %added_softs } = values %added_softs;

  return;
}


#
# Identify possible CPE entries for each possible (vendor,product) found
#
sub identify_possible_cpe_entries {
 
  my $sth = $dbh->prepare("SELECT rowid FROM SOFTS WHERE VENDOR=? AND SOFT=? LIMIT 1");

  while ( my ($vendor, $vendor_confidence) = each (%possible_vendors) ) {

    while ( my ($soft, $product_confidence) = each (%possible_products) ) {

      # Lookup (vendor,product) tuple in CPE dictionary
      my $ret =  $sth->execute($vendor,$soft);
      my ($rowid) = $sth->fetchrow_array; 

      # Add to list of possibly matching CPE entries
      if ( $rowid ) {
        $possible_cpe_entries{"$vendor:$soft"} = $vendor_confidence * $product_confidence;
      }

    }

  }

  return;

}

#
# Initialize CPE dictionary database
#
sub init_cpe_dict {

  print "Initialising CPE dictionary database, please wait...\n",

  # Initialise SQLite database
  my $stmt = qq(PRAGMA journal_mode=WAL;);
  my $ret = $dbh->do($stmt); 
  $stmt = qq(PRAGMA synchronous=NORMAL;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(PRAGMA locking_mode=EXCLUSIVE;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(DROP TABLE IF EXISTS SOFTS;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(DROP TABLE IF EXISTS VERSIONS;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(CREATE TABLE SOFTS (
      VENDOR  TEXT NOT NULL,
      SOFT    TEXT NOT NULL);
  );
  $ret = $dbh->do($stmt); 
  $stmt = qq(CREATE TABLE VERSIONS (
      SOFT     INTEGER,
      VERSION  TEXT NOT NULL,
      FOREIGN KEY(SOFT) REFERENCES SOFTS(rowid)
    );
  );
  $ret = $dbh->do($stmt); 

  # Read the official CPE dictionary
  my $parser = XML::LibXML->new();
  my $tree = $parser->parse_file($official_cpe_dictionary);
  my $cpe_dict = $tree->getDocumentElement;
  my @cpe_list = $cpe_dict->getElementsByTagName('cpe-23:cpe23-item');

  # Prepare SQL statements 
  my ($processed,$added) = (1,1);
  my $sth1 = $dbh->prepare("SELECT rowid FROM SOFTS WHERE VENDOR=? AND SOFT=? LIMIT 1");
  my $sth2 = $dbh->prepare("INSERT INTO SOFTS (rowid,VENDOR,SOFT) VALUES (?,?,?)");
  my $sth3 = $dbh->prepare("INSERT INTO VERSIONS (SOFT,VERSION) VALUES (?,?)");

  # Populates the SQLite database from the official CPE dictionary
  foreach my $cpe (@cpe_list) {

    # skip deprecated entries
    my @deprecations = $cpe->getElementsByTagName('cpe-23:deprecation');
    if (@deprecations) { next }

    # get CPE entry's data and add it to SQLite database
    my ($dummy1, $dummy2, $platform, $vendor, $soft, $version, $update, $edition, $lang) = split /(?<!\\)\Q:\E/, $cpe->getAttribute('name');
    msg("Processing \"$vendor:$soft:$version\"",$verbose);

    # Check if the software is already in the db
    $ret = $sth1->execute($vendor,$soft);
    my $rowid = $sth1->fetchrow_array; 

    # Add software only if it isn't in the database yet 
    if ( ! $rowid ) {
      $rowid=$added;
      $ret = $sth2->execute($rowid,$vendor,$soft); 
      $added++;
    }
     
    # Add version anyway
    msg("Inserting ($rowid,$version) in VERSIONS table",$debug);
    $ret = $sth3->execute($rowid,$version); 

    # Report processing info
    print "$processed records processed, $added soft added\r";
    $processed++;
    
  }
  
  print "\ndone\n";

  exit;

}

__END__

=head1 soft2cpe.pl

soft2cpe.pl - Program to translate a software name into a corresponding CPE entry

=head1 SYNOPSIS

soft2cpe.pl [options] "software name"

  Options:
    --debug   print debugging information (implies "--verbose")
    --help    print this text
    --init    initialise the CPE SQLite database file.
    --vendor  provide the name of the software's vendor
    --verbose output verbose processing information 
    --version provide the software's version

=head1 OPTIONS

=over 4

=item B<--debug>

  Output debugging information about what soft2cpl.pl is doing. Implies "--debug".

=item B<--help>
   
  Print help

=item B<--init>

  soft2cpe.pl uses a SQLite database for its operation. This option tells soft2cpe.pl to create this database.

=item B<--vendor> 

  Specify the name of the software vendor.

=item B<--verbose>

  Output verbose information about what soft2cpl.pl is doing. Use "--debug" for even more details.
  
=item B<--version> 

  Specify the version of the software. This option as no effect for the moment.

=back 

=head1 DESCRIPTION

=cut
