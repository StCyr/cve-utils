#!/usr/bin/perl

use Getopt::Long;
use Log::Message::Simple;
use Pod::Usage;
use XML::LibXML;
use DBI;

use warnings;
no warnings 'experimental::smartmatch','once';

binmode STDOUT, ":encoding(UTF-8)";

local $Log::Message::Simple::MSG_FH     = \*STDERR;
local $Log::Message::Simple::DEBUG_FH   = \*STDERR;

# Read config file
require './soft2cpe.conf';

# Get options
my ($debug,$help,$init,$verbose) = 0;
my ($vendor,$version);

GetOptions( 'debug' => \$debug,
  'help' => \$help,
  'init' => \$init,
  'vendor=s'  => \$vendor,
  'verbose'   => \$verbose,
  'version=s' => \$version,
);

pod2usage(3) if $help;

$verbose=1 if $debug;

# Open the CPE dictionary SQLite database.
my ($dsn,$dbh);
if ( -f $cpe_dictionary or $init) {
  $dsn = "DBI:SQLite:dbname=$cpe_dictionary";
  $dbh = DBI->connect( $dsn,'','', {RaiseError => 1} ) or die $DBI::errstr;
} else {
  die "No CPE dictionary found, aborting. Please use \"--init\" to create one (See \"--help\" for more info).";
}

# Initialise a new CPE dictionary if requested
init_cpe_dict() if ($init);

# At least a soft name must be given
my $soft = $ARGV[0];
if ( !defined $soft and !defined $init) {
  pod2usage(3);
  exit 1;
}

# Do some basic CPE formating on vendor and product
$vendor =~ tr/ A-Z/_a-z/ ; 
$vendor =~ s/\+/\\\+/g; 
$vendor =~ s/[^\x20-\x7e]/_/g;
$vendor =~ s|/|\\/|g; 
$soft =~ tr/\t A-Z/__a-z/ ; 
$soft =~ s/\+/\\\+/g; 
$soft =~ s/[^\x20-\x7e]/_/g;
$soft =~ s|/|\\/|g; 

# Some products need to be skipped (eg: MS updates,...)
foreach my $skip ( @products2skip ) {
  if ( $soft =~ /$skip/ ) {
    die "Skipping product $soft.\n";
  }
} 

# Identify possible products
my %possible_products;
identify_possible_products();

# Identify possible CPE entries
my %possible_cpe_entries;
lookup_possible_cpe();

# Verbose output
msg("Following possible products were found:",$verbose);
msg("$_ $possible_products{$_}",$verbose) for (keys %possible_products);
msg("Following possible CPE entries were found:",$verbose);
msg("$_ $possible_cpe_entries{$_}",$verbose) for (keys %possible_cpe_entries);


# Output best CPE entry found
my $match = keys %possible_cpe_entries;
if ($match) {

  # update possible CPE entries confidence based on provided vendor name
  if ($vendor) {
    update_vendors_confidence();
  } else {
    msg("No vendor name provided; Can't update confidence",$verbose);
  }
  
  # Order list by increasing order of confidence
  msg("** Following possible CPE entries were found (ordered by increasing confidence): **",$verbose);
  my $best_cpe = "";
  foreach my $cpe (sort { $possible_cpe_entries{$a} <=> $possible_cpe_entries{$b} } keys %possible_cpe_entries) {
      $best_cpe = $cpe;
      my $string = sprintf( "$cpe (confidence: %.2f)" , $possible_cpe_entries{$cpe} );
      msg($string,$verbose);
  }

  print "$best_cpe\n";
  exit 0;

} else {
  msg("No match found.",$verbose);
  exit -1;
}


###############################
#
# Sub routines start here
#
###############################


#
# Identify all possible vendors based on the given vendor name
#
sub update_vendors_confidence {
  my @possible_vendors;

  msg("** Trying to find most possible vendors",$verbose);

  # Try to match vendor against a known pattern
  debug("Trying to match \"$vendor\" against a known pattern",$debug);
  while ( my ($key, $value) = each (%vendor_match) ) {
    debug("  Trying to match \"$vendor\" against \"$key\"",$debug);
    if ( $vendor =~ /$key/ or $vendor =~ /\Q$key\E/ ) {
      debug("  Matched \"$vendor\" against \"$key\"",$debug);
      push @possible_vendors, $value;
      debug("  Added \"$value\" to the list of possible vendors",$debug);
    }
  }

  # Try to find a leading vendor name in products' name
  debug("Trying to find a leading vendor name in product name",$debug);
  foreach my $to_trim ( @product_leading_vendor ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      debug("  Trying to find leading \"$to_trim\" in \"$product\"",$debug);
      my ($trimmed) = $product =~ /^$to_trim(.*)/;
      # Add found vendor name to the list of possible vendor if not yet done
      if ( $trimmed ) {
        my $possible_vendor = substr($to_trim, 0, -1);
        if ( ! grep($possible_vendor, @possible_vendors) ) {
          push @possible_vendors, $possible_vendor;
          debug("  Added \"$possible_vendor\" to the list of possible vendors",$debug);
        }
      }
    }
  }

  msg("Following possible vendors were found:",$verbose);
  foreach (@possible_vendors) {
    msg("$_",$verbose);
  }

  # Update confidence based on possible vendors found
  msg("** Updating confidence based on possible vendors found",$verbose);
  while ( my ($key, $value) = each (%possible_cpe_entries) ) {
    my ($v,$s) = split /:/,$key;
    if ( grep( /$v/ , @possible_vendors ) ) {
      debug("  Found \"$v\" in list of possible vendors => raising confidence of CPE \"$key\"",$debug);
      $possible_cpe_entries{$key} = $value / 0.6;
    }
  }

  return;

} 



# Identify all possible products based on the given product name, and return an hash array 
# containing all possible products with a confidence rating.
sub identify_possible_products {
  my %added_softs;
  
  msg("** Trying to identify possible product(s)",$verbose);

  $possible_products{$soft} = 0.8;

  # Try to remove leading vendor name from product name
  msg("Trying to remove leading vendor name from product name",$verbose);
  foreach my $to_trim ( @product_leading_vendor ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      debug("Trying to remove leading \"$to_trim\" from \"$product\"",$debug);
      my ($trimmed) = $product =~ /^$to_trim(.*)/;
      if ( $trimmed ) {
        debug("Removed leading \"$to_trim\" from \"$product\"",$debug);
        $added_softs{$trimmed} = $confidence / 0.9;
      }
    }
  }

  # Add trimmed soft to possible_products and reset hash and iterators
  @possible_products{ keys %added_softs } = values %added_softs;
  keys %possible_products;
  %added_softs=();

  # Try to remove some trailing crap from product name
  msg("Trying to remove trailing crap from product name",$verbose);
  foreach my $regex ( @product_trailing_crap ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      debug("Trying to remove trailing \"$regex\" in \"$soft\"",$debug);
      if ( $product =~ /$regex/ ) {
        debug("Removed trailing \"$2\" in \"$soft\"",$debug);
        my $trimmed = $1;
        $added_softs{$trimmed} = $confidence / 0.9;
      }
    }
  }

  # Add trimmed soft to possible_products and reset hash and iterators
  @possible_products{ keys %added_softs } = values %added_softs;
  keys %possible_products;
  %added_softs=();

  # Try to detect language in product name, and remove it if found
  msg("Trying to detect language and remove it from product name",$verbose);
  foreach my $regex ( @languages ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      debug("Trying to identify \"$regex\" in \"$soft\"",$debug);
      if ( $product =~ s/$regex//g ) {
        $added_softs{$product} = $confidence / 0.9;
        debug("Found \"$regex\" => Added \"$product\" to the list of possible product",$debug);
      }
    }
  }

  # Add trimmed soft to possible_products and reset hash and iterators
  @possible_products{ keys %added_softs } = values %added_softs;
  keys %possible_products;
  %added_softs=();

  # Try to remove unnecessary trailing version number from product name
  msg("Trying to remove trailing version number from product name",$verbose);
  foreach my $regex ( @version_regex ) {
    while ( my ($product, $confidence) = each (%possible_products) ) {
      debug("Trying to identify version with \"$regex\" in \"$soft\"",$debug);
      if ( $product =~ /$regex/ ) {
        my $trimmed = $1;
        my $version = $2;
        $added_softs{$trimmed} = $confidence / 0.9;
        debug("Identified version \"$version\" with \"$regex\" in \"$soft\"",$debug);
      }
    }
  }

  # Add trimmed soft to possible_products and reset hash and iterators
  @possible_products{ keys %added_softs } = values %added_softs;
  keys %possible_products;
  %added_softs=();

  # Try to match product against a known pattern
  msg("Trying to match product against a known pattern",$verbose);
  while ( my ($product, $confidence) = each (%possible_products) ) {
    while ( my ($key, $value) = each (%product_aliases) ) {
      debug("Trying to match \"$product\" against \"$key\"",$debug);
      if ( $product =~ /$key/ ) {
        debug("Matched \"$product\" against \"$key\"",$debug);
        $added_softs{$value} = $confidence / 0.8;
      }
    }
  }

  # Add modified soft to possible_products
  @possible_products{ keys %added_softs } = values %added_softs;

  return;
}

#
# Lookup all possible cpe based on the possible software names found
#
sub lookup_possible_cpe {

  my $sth = $dbh->prepare("SELECT VENDOR FROM SOFTS WHERE SOFT=?");

  msg("** Looking up possible CPE",$verbose);

  while ( my ($product, $confidence) = each (%possible_products) ) {

    debug("Looking up possible vendors for product \"$product\"",$debug);

    my $ret = $sth->execute($product);

    while ( my $vendor = $sth->fetchrow_array) {
      debug("Found \"$vendor\" for product \"$product\" => Adding possible CPE \"$vendor:$product\" with confidence $confidence",$debug);
      $possible_cpe_entries{"$vendor:$product"} = $confidence;
    }

  }
    
}


#
# Initialize CPE dictionary database
#
sub init_cpe_dict {

  print "Initialising CPE dictionary database, please wait...\n",

  # Initialise SQLite database
  my $stmt = qq(PRAGMA journal_mode=WAL;);
  my $ret = $dbh->do($stmt); 
  $stmt = qq(PRAGMA synchronous=NORMAL;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(PRAGMA locking_mode=EXCLUSIVE;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(DROP TABLE IF EXISTS SOFTS;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(DROP TABLE IF EXISTS VERSIONS;);
  $ret = $dbh->do($stmt); 
  $stmt = qq(CREATE TABLE SOFTS (
      VENDOR  TEXT NOT NULL,
      SOFT    TEXT NOT NULL);
  );
  $ret = $dbh->do($stmt); 
  $stmt = qq(CREATE TABLE VERSIONS (
      SOFT     INTEGER,
      VERSION  TEXT NOT NULL,
      FOREIGN KEY(SOFT) REFERENCES SOFTS(rowid)
    );
  );
  $ret = $dbh->do($stmt); 

  # Read the official CPE dictionary
  my $parser = XML::LibXML->new();
  my $tree = $parser->parse_file($official_cpe_dictionary);
  my $cpe_dict = $tree->getDocumentElement;
  my @cpe_list = $cpe_dict->getElementsByTagName('cpe-23:cpe23-item');

  # Prepare SQL statements 
  my ($processed,$added) = (1,1);
  my $sth1 = $dbh->prepare("SELECT rowid FROM SOFTS WHERE VENDOR=? AND SOFT=? LIMIT 1");
  my $sth2 = $dbh->prepare("INSERT INTO SOFTS (rowid,VENDOR,SOFT) VALUES (?,?,?)");
  my $sth3 = $dbh->prepare("INSERT INTO VERSIONS (SOFT,VERSION) VALUES (?,?)");

  # Populates the SQLite database from the official CPE dictionary
  foreach my $cpe (@cpe_list) {

    # skip deprecated entries
    my @deprecations = $cpe->getElementsByTagName('cpe-23:deprecation');
    if (@deprecations) { next }

    # get CPE entry's data and add it to SQLite database
    my ($dummy1, $dummy2, $platform, $vendor, $soft, $version, $update, $edition, $lang) = split /(?<!\\)\Q:\E/, $cpe->getAttribute('name');
    msg("Processing \"$vendor:$soft:$version\"",$verbose);

    # Check if the software is already in the db
    $ret = $sth1->execute($vendor,$soft);
    my $rowid = $sth1->fetchrow_array; 

    # Add software only if it isn't in the database yet 
    if ( ! $rowid ) {
      $rowid=$added;
      $ret = $sth2->execute($rowid,$vendor,$soft); 
      $added++;
    }
     
    # Add version anyway
    msg("Inserting ($rowid,$version) in VERSIONS table",$debug);
    $ret = $sth3->execute($rowid,$version); 

    # Report processing info
    print "$processed records processed, $added soft added\r";
    $processed++;
    
  }
  
  print "\ndone\n";

  exit;

}

__END__

=head1 soft2cpe.pl

soft2cpe.pl - Program to translate a software name into a corresponding CPE entry

=head1 SYNOPSIS

soft2cpe.pl [options] "software name"

  Options:
    --debug   print debugging information (implies "--verbose")
    --help    print this text
    --init    initialise the CPE SQLite database file.
    --vendor  provide the name of the software's vendor
    --verbose output verbose processing information 
    --version provide the software's version

=head1 OPTIONS

=over 4

=item B<--debug>

  Output debugging information about what soft2cpl.pl is doing. Implies "--debug".

=item B<--help>
   
  Print help

=item B<--init>

  soft2cpe.pl uses a SQLite database for its operation. This option tells soft2cpe.pl to create this database.

=item B<--vendor> 

  Specify the name of the software vendor.

=item B<--verbose>

  Output verbose information about what soft2cpl.pl is doing. Use "--debug" for even more details.
  
=item B<--version> 

  Specify the version of the software. This option as no effect for the moment.

=back 

=head1 DESCRIPTION

=cut
